---
layout: post
title: Webpack优化
date: 2019-06-25 16:14:22
author: 'AlenQi'
header-img: 'bg.jpg'
tags:
  - 前端开发
  - 优化
---

> Webpack 是现在主流的功能强大的模块化打包工具，在使用 Webpack 时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等。不同于`gulp`、`grunt`等打包工具，Webpack 是模块化的。

## 一、优化构建速度

1. 缩小文件的搜索范围

- 利用 resolve 字段

  1. 设置 resolve.modules:[path.resolve(__dirname, 'node_modules')]避免层层查找
  2. 设置 resolve.mainFields:['main']，设置尽量少的值可以减少入口文件的搜索步骤
  3. 对庞大的第三方模块设置 resolve.alias, 使 webpack 直接使用库的 min 文件，避免库内解析
  4. 合理配置 resolve.extensions，减少文件查找

- module.noParse 字段告诉 Webpack 不必解析哪些文件，可以用来排除对非模块化库文件的解析

- 配置 loader 时，通过 test、exclude、include 缩小搜索范围

2. 使用 DllPlugin 减少基础模块编译次数

- DllPlugin 动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到 dll 文件中，当需要导入的模块存在于某个 dll 中时，这个模块不再被打包，而是去 dll 中获取。**为什么会提升构建速度呢？**原因在于 dll 中大多包含的是常用的第三方模块，如 react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。这样做和配置 resolve.alias 和 module.noParse 的效果有异曲同工的效果

3. 使用 HappyPack 开启多进程 Loader 转换

- 在整个构建流程中，最耗时的就是 Loader 对文件的转换操作了，而运行在 Node.js 之上的 Webpack 是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack 可以将任务分解给多个子进程，最后将结果发给主进程。JS 是单线程模型，只能通过这种多进程的方式提高性能

4. 使用 ParallelUglifyPlugin 开启多进程压缩 JS 文件

- 使用 UglifyJS 插件压缩 JS 代码时，需要先将代码解析成 Object 表示的 AST（抽象语法树），再去应用各种规则去分析和处理 AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin 可以开启多个子进程，每个子进程使用 UglifyJS 压缩代码，可以并行执行，能显著缩短压缩时间

## 二、优化开发体验

1. 使用自动刷新

- Webpack 监听文件

- DevServer 刷新浏览器

1. 开启模块热替换 HMR

- 模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个 chunk 中注入代理客户端来连接 DevServer 和网页, 开启后如果修改子模块就可以实现局部刷新

## 三、优化输出质量-压缩文件体积

1. 区分环境--减小生产环境代码体积

2. 压缩代码-JS、ES、CSS

3. 使用 Tree Shaking 剔除 JS 死代码

## 四、优化输出质量--加速网络请求

1. 使用 CDN 加速静态资源加载

- HTML 文件：放在自己的服务器上且关闭缓存，不接入 CDN

- 静态的 JS、CSS、图片等资源：开启 CDN 和缓存，同时文件名带上由内容计算出的 Hash 值，这样只要内容变化 hash 就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。

- 不同类型资源放在不同域名的 CDN 上

2. 多页面应用提取页面间公共代码，以利用缓存

- 原理：大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的 chunk 中都会包含公共代码，相当于要传输 n 份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。

- 应用方法：

  1. 利用 CommonsChunkPlugin 把多个页面依赖的公共代码提取到 common.js 中
  2. 找出依赖的基础库，写一个 base.js 文件，再与 common.js 提取公共代码到 base 中，common.js 就剔除了基础库代码，而 base.js 保持不变
  3. 得到基础库代码 base.js，不含基础库的公共代码 common.js，和页面各自的代码文件 xx.js

3. 分割代码以按需加载

- 原理：

  1. 将网站功能按照相关程度划分成几类
  2. 每一类合并成一个 Chunk，按需加载对应的 Chunk
  3. 例如，只把首屏相关的功能放入执行入口所在的 Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载

- 做法：

  `import(/_ webpackChunkName:show _/ './show').then()` 是实现按需加载的关键，Webpack 内置对 `import( \*)`语句的支持，Webpack 会以`./show.js` 为入口重新生成一个 Chunk。代码在浏览器上运行时只有点击了按钮才会开始加载 `show.js`，且 `import` 语句会返回一个 `Promise`，加载成功后可以在 then 方法中获取加载的内容。这要求浏览器支持 `Promise API`，对于不支持的浏览器，需要注入 `Promise polyfill`。

## 五、优化输出质量--提升代码运行时的效率

1. 使用 Prepack 提前求值

- 原理：

  Prepack 是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在编译阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在 Prepack 还不够成熟，用于线上环境还为时过早

2. 使用 Scope Hoisting

- 原理：

  译作`作用域提升`，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了 ES6 模块化的，否则 Webpack 会降级处理不采用 Scope Hoisting

## 六、使用输出分析工具

1. webpack-bundle-analyzer
